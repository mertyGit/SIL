<!DOCTYPE html>

<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>layer.c</title><link rel="stylesheet" type="text/css" href="../styles/main.css" /><script type="text/javascript" src="../styles/main.js"></script><script type="text/javascript">NDLoader.LoadJS("Content", "../styles/");</script></head>

<!-- Generated by Natural Docs, version 2.2 -->

<!-- saved from url=(0016)http://localhost -->

<body onload="NDLoader.OnLoad('Content');" class="NDPage NDContentPage">

<a name="Functions"></a><a name="Topic9"></a><div class="CTopic TGroup LC first">
 <div class="CTitle">Functions</div>
</div>

<a name="sil_addLayer"></a><a name="Topic6"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sil_addLayer</div>
 <div id="NDPrototype6" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">SILLYR *sil_addLayer(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first"><span class="SHKeyword">int</span>&nbsp;</td><td class="PName last">relx,</td></tr><tr><td class="PType first"><span class="SHKeyword">int</span>&nbsp;</td><td class="PName last">rely,</td></tr><tr><td class="PType first">UINT&nbsp;</td><td class="PName last">width,</td></tr><tr><td class="PType first">UINT&nbsp;</td><td class="PName last">height,</td></tr><tr><td class="PType first">BYTE&nbsp;</td><td class="PName last">type</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Create a layer and put to top of stack of layers</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">relx<div class="CDLParameterType"><span class="SHKeyword">int</span></div></td><td class="CDLDefinition"><p>x position relative to top left of display</p></td></tr><tr><td class="CDLEntry">rely<div class="CDLParameterType"><span class="SHKeyword">int</span></div></td><td class="CDLDefinition"><p>y position relative to top left of display</p></td></tr><tr><td class="CDLEntry">width<div class="CDLParameterType">UINT</div></td><td class="CDLDefinition"><p>width of layer</p></td></tr><tr><td class="CDLEntry">height<div class="CDLParameterType">UINT</div></td><td class="CDLDefinition"><p>height of layer</p></td></tr><tr><td class="CDLEntry">type<div class="CDLParameterType">BYTE</div></td><td class="CDLDefinition"><p>RGB type to store (see: <a href="../index.html#File:sil.h:RGB_types" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,18);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >RGB types</a>). Use '0' to use same type as the one from the display.</p></td></tr></table><div class="CHeading">Returns</div><p>pointer to created layer or NULL if error occured</p><div class="CHeading">Remarks</div><p>addLayer adds the layer on top of the stack of existing layers.&nbsp; If you want them somewhere else in the stack, use the &quot;to..&quot; sil functions afterwards: &lt;sil_toTop()&gt;,&lt;sil_toBottom()&gt;,&lt;sil_toAbove()&gt;,&lt;sil_toBelow()&gt; or even &lt;sil_swap()&gt;</p></div>
</div>

<a name="sil_setHoverHandler"></a><a name="Topic25"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sil_setHoverHandler</div>
 <div id="NDPrototype25" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> sil_setHoverHandler(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td class="PType">SILLYR&nbsp;</td><td class="PSymbols">*</td><td class="PName last">layer,</td></tr><tr><td class="PModifierQualifier first">UINT (*</td><td class="PType">hover</td><td class="PSymbols">)(</td><td class="PName last">SILEVENT *)</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Set handler for &quot;hover&quot;, when mousepointer is above the given layer, it will trigger the given hoverhandler. Handlers will receive the event, including targeted layer and should return '0' for &quot;do nothing&quot; or '1' for &quot;update display&quot;.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">layer<div class="CDLParameterType">SILLYR*</div></td><td class="CDLDefinition"><p>layer to attach handler to</p></td></tr><tr><td class="CDLEntry">hover</td><td class="CDLDefinition"><p>addresss of the handler function</p></td></tr></table><div class="CHeading">Remarks</div><ul><li><p><b>event-&gt;type</b> can be of:</p><ul><li><p><b>SILDISP_MOUSE_MOVE</b>&nbsp; : Mousepointer is moving within the view (and above visible pixels)</p></li><li><p><b>SILDISP_MOUSE_LEFT</b>&nbsp; : Mousepointer left the view of the layer</p></li><li><p><b>SILDISP_MOUSE_ENTER</b>&nbsp; : Mousepointer enters the view of the layer</p></li></ul></li><li><p><b>event-&gt;x, event-&gt;y</b> will be the coordinates of the mouse pointer within the layer.</p></li><li><p><b>event-&gt;dx, event-&gt;dy</b> will be the difference between previous and this movement</p></li><li><p>Like all handlers, setting this handler to NULL will prevent these events send to the layer</p></li><li><p>By default, the function will only triggers if mousepointer is above layer <b>and</b> there is a visible pixel. If you set the layer flag for <b>SILFLAG_MOUSEALLPIX</b>, it will use all pixels within view, visible or not. However, the layer might be blocking visible pixels of the layers underneath.</p></li></ul></div>
</div>

<a name="sil_setClickHandler"></a><a name="Topic26"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sil_setClickHandler</div>
 <div id="NDPrototype26" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> sil_setClickHandler(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td class="PType">SILLYR&nbsp;</td><td class="PSymbols">*</td><td class="PName last">layer,</td></tr><tr><td class="PModifierQualifier first">UINT (*</td><td class="PType">click</td><td class="PSymbols">)(</td><td class="PName last">SILEVENT *)</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Set handler for &quot;click&quot;, when mousepointer is above the given layer AND mousebutton has been pressed, it will trigger the given clickhandler.&nbsp; Handlers will receive the event, including targeted layer and should return '0' for &quot;do nothing&quot; or '1' for &quot;update display&quot;.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">layer<div class="CDLParameterType">SILLYR*</div></td><td class="CDLDefinition"><p>layer to attach handler to</p></td></tr><tr><td class="CDLEntry">click</td><td class="CDLDefinition"><p>addresss of the handler function</p></td></tr></table><div class="CHeading">Remarks</div><ul><li><p>Only 3 mousebuttons are recognized:</p><ul><li><p><b>SIL_BTN_LEFT</b></p></li><li><p><b>SIL_BTN_MIDDLE</b> (same as scrollwheel click)</p></li><li><p><b>SIL_BTN_RIGHT</b></p></li></ul></li><li><p>Mousewheel event is also converted to a &quot;click&quot;</p><ul><li><p><b>SIL_WHEEL_UP</b> rotating upwards</p></li><li><p><b>SIL_WHEEL_DOWN</b> rotating downwards</p></li></ul></li><li><p><b>event-&gt;type</b> can be of:</p><ul><li><p><b>SILDISP_MOUSE_DOWN</b>&nbsp; : mousebutton is clicked, <b>event-&gt;val</b> contains mousebutton code</p></li><li><p><b>SILDISP_MOUSE_UP</b>&nbsp; : mousebutton is released, <b>event-&gt;val</b> contains mousebutton code</p></li><li><p><b>SILDISP_MOUSEWHEEL</b>&nbsp; : mousewheel is rotated, <b>event-&gt;val</b> contains wheel code</p></li></ul></li><li><p><b>event-&gt;x,event-&gt;y</b> will contain the current location of the mousepointer within display (!), so not within layer,&nbsp; because mouse-up event might even happen outside of layer</p></li><li><p><b>event-&gt;val</b> will contain button/wheel code</p></li><li><p>Like all handlers, setting this handler to NULL will prevent these events send to the layer</p></li></ul><div class="CHeading">Example</div><p>( file &quot;example_clickhandler.c&quot; in examples directory )</p><pre class="CCode">#include &lt;stdio.h&gt;<br />#include <span class="SHString">&quot;sil.h&quot;</span><br />#include <span class="SHString">&quot;log.h&quot;</span><br /><br />SILLYR *whitelayer,*yellowlayer;<br /><br />UINT myclick(SILEVENT *<span class="SHKeyword">event</span>) {<br />  log_info(<span class="SHString">&quot;---------------------------&quot;</span>);<br />  log_info(<span class="SHString">&quot;GOT Click Event !&quot;</span>);<br />  <span class="SHKeyword">if</span> (whitelayer==<span class="SHKeyword">event</span>-&gt;layer) {<br />    log_info(<span class="SHString">&quot;From white rectangle layer&quot;</span>);<br />  } <span class="SHKeyword">else</span> {<br />    log_info(<span class="SHString">&quot;From yellow rectangle layer&quot;</span>);<br />  }<br />  <span class="SHKeyword">switch</span> (<span class="SHKeyword">event</span>-&gt;type) {<br />    <span class="SHKeyword">case</span> SILDISP_MOUSE_DOWN:<br />      log_info(<span class="SHString">&quot;Mouse Down at %d,%d&quot;</span>,<span class="SHKeyword">event</span>-&gt;x,<span class="SHKeyword">event</span>-&gt;y);<br />      <span class="SHKeyword">if</span> (<span class="SHKeyword">event</span>-&gt;val&amp;SIL_BTN_LEFT) log_info(<span class="SHString">&quot;LEFT pressed&quot;</span>);<br />      <span class="SHKeyword">if</span> (<span class="SHKeyword">event</span>-&gt;val&amp;SIL_BTN_MIDDLE) log_info(<span class="SHString">&quot;MIDDLE pressed&quot;</span>);<br />      <span class="SHKeyword">if</span> (<span class="SHKeyword">event</span>-&gt;val&amp;SIL_BTN_RIGHT) log_info(<span class="SHString">&quot;RIGHT pressed&quot;</span>);<br />      <span class="SHKeyword">break</span>;<br />    <span class="SHKeyword">case</span> SILDISP_MOUSE_UP:<br />      log_info(<span class="SHString">&quot;Mouse Up at %d,%d&quot;</span>,<span class="SHKeyword">event</span>-&gt;x,<span class="SHKeyword">event</span>-&gt;y);<br />      <span class="SHKeyword">if</span> (<span class="SHKeyword">event</span>-&gt;val&amp;SIL_BTN_LEFT) log_info(<span class="SHString">&quot;LEFT released&quot;</span>);<br />      <span class="SHKeyword">if</span> (<span class="SHKeyword">event</span>-&gt;val&amp;SIL_BTN_MIDDLE) log_info(<span class="SHString">&quot;MIDDLE released&quot;</span>);<br />      <span class="SHKeyword">if</span> (<span class="SHKeyword">event</span>-&gt;val&amp;SIL_BTN_RIGHT) log_info(<span class="SHString">&quot;RIGHT released&quot;</span>);<br />      <span class="SHKeyword">break</span>;<br />    <span class="SHKeyword">case</span> SILDISP_MOUSEWHEEL:<br />      log_info(<span class="SHString">&quot;Mouse Wheel at %d,%d&quot;</span>,<span class="SHKeyword">event</span>-&gt;x,<span class="SHKeyword">event</span>-&gt;y);<br />      <span class="SHKeyword">if</span> (SIL_WHEEL_UP==<span class="SHKeyword">event</span>-&gt;val) {<br />        log_info(<span class="SHString">&quot;Wheel Up&quot;</span>);<br />      } <span class="SHKeyword">else</span> {<br />        log_info(<span class="SHString">&quot;Wheel Down&quot;</span>);<br />      }<br />      <span class="SHKeyword">break</span>;<br />  }<br /><br />  <span class="SHKeyword">return</span> <span class="SHNumber">0</span>; <span class="SHComment">// Don't need no screen update afterwards</span><br />}<br /><br /><span class="SHKeyword">int</span> main() {<br />  sil_initSIL(<span class="SHNumber">200</span>,<span class="SHNumber">200</span>,<span class="SHString">&quot;basic example&quot;</span>,NULL);<br /><br />  whitelayer=sil_addLayer(<span class="SHNumber">10</span>,<span class="SHNumber">10</span>,<span class="SHNumber">150</span>,<span class="SHNumber">150</span>,SILTYPE_ABGR);<br />  sil_setForegroundColor(SILCOLOR_WHITE,<span class="SHNumber">255</span>);<br />  sil_setDrawWidth(<span class="SHNumber">4</span>);<br />  sil_drawRectangle(whitelayer,<span class="SHNumber">0</span>,<span class="SHNumber">0</span>,<span class="SHNumber">150</span>,<span class="SHNumber">150</span>);<br /><br />  yellowlayer=sil_addLayer(<span class="SHNumber">20</span>,<span class="SHNumber">20</span>,<span class="SHNumber">150</span>,<span class="SHNumber">150</span>,SILTYPE_ABGR);<br />  sil_setForegroundColor(SILCOLOR_YELLOW,<span class="SHNumber">200</span>);<br />  sil_setDrawWidth(<span class="SHNumber">4</span>);<br />  sil_drawRectangle(yellowlayer,<span class="SHNumber">0</span>,<span class="SHNumber">0</span>,<span class="SHNumber">150</span>,<span class="SHNumber">150</span>);<br /><br />  <span class="SHComment">// link our own click handler to both layers</span><br />  sil_setClickHandler(whitelayer,myclick);<br />  sil_setClickHandler(yellowlayer,myclick);<br /><br /><br />  sil_updateDisplay();<br />  sil_mainLoop();<br />  sil_destroySIL();<br />}</pre></div>
</div>

<a name="sil_setKeyHandler"></a><a name="Topic22"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sil_setKeyHandler</div>
 <div id="NDPrototype22" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> sil_setKeyHandler(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td class="PType">SILLYR&nbsp;</td><td class="PSymbols">*</td><td class="PName last">layer,</td></tr><tr><td class="first"></td><td class="PType">UINT&nbsp;</td><td></td><td class="PName last">key,</td></tr><tr><td class="first"></td><td class="PType">BYTE&nbsp;</td><td></td><td class="PName last">modifiers,</td></tr><tr><td class="first"></td><td class="PType">BYTE&nbsp;</td><td></td><td class="PName last">flags,</td></tr><tr><td class="PModifierQualifier first">UINT (*</td><td class="PType">keypress</td><td class="PSymbols">)(</td><td class="PName last">SILEVENT *)</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Set handler for keyboard events.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">layer<div class="CDLParameterType">SILLYR*</div></td><td class="CDLDefinition"><p>layer to attach handler to</p></td></tr><tr><td class="CDLEntry">key<div class="CDLParameterType">UINT</div></td><td class="CDLDefinition"><p>keycode to trigger on</p></td></tr><tr><td class="CDLEntry">modifiers<div class="CDLParameterType">BYTE</div></td><td class="CDLDefinition"><p>flags of extra modifiers keys that has to be pressed at same time</p></td></tr><tr><td class="CDLEntry">flags<div class="CDLParameterType">BYTE</div></td><td class="CDLDefinition"><p>extra options</p></td></tr></table><div class="CHeading">Key</div><p>A single key from <a href="../index.html#File:sil.h:Keyboard_codes" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,23);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >Keyboard codes</a>, or '0' to get all key codes (if modifiers is also set to '0')</p><div class="CHeading">Modifiers</div><p>One or more modifierkeys that has to be pressed can be selected concatting with 'or' for example SILKM_SHIFT|SILKM_ALT to trigger keyhandler only when keycode + shift + alt are pressed at the same time</p><ul><li><p><b>SILKM_SHIFT</b></p></li><li><p><b>SILKM_ALT</b></p></li><li><p><b>SILKM_CTRL</b></p></li><li><p><b>SILKM_CAPS</b></p></li></ul><p>Note that there is no difference between left or right of same modifier type</p><div class="CHeading">Flags</div><p>These can also be combined together with or ('|'):</p><table class="CDefinitionList"><tr><td class="CDLEntry">* SILKT_SINGLE</td><td class="CDLDefinition"><p>Ignore any autorepeat, just send code once</p></td></tr><tr><td class="CDLEntry">* SILKT_ONLYUP</td><td class="CDLDefinition"><p>Don't send any <b>SILDISP_KEY_DOWN</b> event, only the <b>SILDISP_KEY_UP</b></p></td></tr></table><div class="CHeading">Event</div><p>Two event types can be send to handler:</p><table class="CDefinitionList"><tr><td class="CDLEntry">* KEY_DOWN</td><td class="CDLDefinition"><p>key has been pressed (or is still being pressed, depending on SILKT_SINGLE flag if you want or don't want those additional events )</p></td></tr><tr><td class="CDLEntry">* KEY_UP</td><td class="CDLDefinition"><p>key has been released</p></td></tr><tr><td class="CDLEntry"><b>event-&gt;key</b></td><td class="CDLDefinition"><p>&quot;native&quot; code translated to one of the <a href="../index.html#File:sil.h:Keyboard_codes" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,23);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >Keyboard codes</a>, platform independend</p></td></tr><tr><td class="CDLEntry"><b>event-&gt;modifiers</b></td><td class="CDLDefinition"><p>Any special keys pressed at the same time (shift,alt,ctrl and or caps)</p></td></tr><tr><td class="CDLEntry"><b>event-&gt;val</b></td><td class="CDLDefinition"><p>Will be the &quot;guessed&quot; character, based on modifier key like shift and caps.&nbsp; It is like event-&gt;key but with the right case</p></td></tr><tr><td class="CDLEntry"><b>event-&gt;code</b></td><td class="CDLDefinition"><p>Will be the &quot;native&quot;,&quot;scancode&quot; or &quot;raw&quot; keycode that might be different per platform.&nbsp; This is without &quot;translating&quot; it what really is printed on the keycap;</p></td></tr></table><div class="CHeading">Remarks</div><ul><li><p>The highest layer with matching key/modifiers will be triggered.&nbsp; By doing so you can &quot;bind&quot; special keycombo's per layer, for instance menu items.</p></li><li><p>Like all handlers, setting this handler to NULL will prevent these events send to the layer</p></li><li><p>The layer doesn't have to be visible to receive keyevents</p></li><li><p>By setting both key and modifiers to zero, you create a &quot;catch all&quot; for all keyboard codes.&nbsp; You can choose to have one layer handler handle - or dispatch - all pressed keys to make it less complex</p></li><li><p>Depending on platform, some keycombinations cannot be intercepted and are handled directly by operating system, like ALT-F4 or CTRL-C.</p></li><li><p>Don't use <b>event-&gt;x</b> or <b>event-&gt;y</b>; they might be not set at all or lagging.&nbsp; Use &lt;sil_getMouse()&gt; to retrieve to current location of mouse pointer if needed.</p></li><li><p><b>event-&gt;val</b> is only one byte, so it will probably misintepret any 'special' UTF-8 keyboard codes longer then one byte. Try to look at <b>event-&gt;code</b> in these cases</p></li></ul></div>
</div>

<a name="sil_setDragHandler"></a><a name="Topic17"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sil_setDragHandler</div>
 <div id="NDPrototype17" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> sil_setDragHandler(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="first"></td><td class="PType">SILLYR&nbsp;</td><td class="PSymbols">*</td><td class="PName last">layer,</td></tr><tr><td class="PModifierQualifier first">UINT (*</td><td class="PType">drag</td><td class="PSymbols">)(</td><td class="PName last">SILEVENT *)</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Set handler for &quot;drag&quot;.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">layer<div class="CDLParameterType">SILLYR*</div></td><td class="CDLDefinition"><p>layer to attach handler to</p></td></tr><tr><td class="CDLEntry">drag</td><td class="CDLDefinition"><p>addresss of the handler function</p></td></tr></table><div class="CHeading">Remarks</div><p>Drag is actually combination of 2 events,&nbsp; mouseclick &amp; move, that will be &quot;translated&quot; by SIL to a drag event if there is a drag handler linked to the layer where mouseclick happend.&nbsp; The handler will recieve the event with the &quot;proposed&quot; new x,y coordinates of the layer in <b>event-&gt;x</b> and <b>event-&gt;y</b> and change since last event in <b>event-&gt;dx</b> and <b>event-&gt;dy</b>.&nbsp; These will be the target coordinates of the layer within the display, not the current (!).&nbsp; Returning 0 will ignores the proposed coordinates, returning 1 will set the layer at the proposed coordinates and updates the display.&nbsp; This way you will have a simple way to define &quot;boundaries&quot; for dragging layers or even handle your own &quot;dragging/shifting/moving&quot; algorithm and returning 0.</p></div>
</div>

<a name="sil_moveLayer"></a><a name="Topic20"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sil_moveLayer</div>
 <div id="NDPrototype20" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> sil_moveLayer(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">SILLYR&nbsp;</td><td class="PSymbols">*</td><td class="PName last">layer,</td></tr><tr><td class="PType first"><span class="SHKeyword">int</span>&nbsp;</td><td></td><td class="PName last">x,</td></tr><tr><td class="PType first"><span class="SHKeyword">int</span>&nbsp;</td><td></td><td class="PName last">y</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Move layer to new position, relative to current position</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">layer<div class="CDLParameterType">SILLYR*</div></td><td class="CDLDefinition"><p>Layer to move</p></td></tr><tr><td class="CDLEntry">x<div class="CDLParameterType"><span class="SHKeyword">int</span></div></td><td class="CDLDefinition"><p>distance to move on X axis (can be negative)</p></td></tr><tr><td class="CDLEntry">y<div class="CDLParameterType"><span class="SHKeyword">int</span></div></td><td class="CDLDefinition"><p>distance to move on Y axis (can be negative)</p></td></tr></table><div class="CHeading">Remarks</div><p>It is possible to move layers outside the boundaries of the display.&nbsp; Of course this will result in the layer not - or partly - being drawn when updating.</p></div>
</div>

<a name="sil_placeLayer"></a><a name="Topic28"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sil_placeLayer</div>
 <div id="NDPrototype28" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> sil_placeLayer(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">SILLYR&nbsp;</td><td class="PSymbols">*</td><td class="PName last">layer,</td></tr><tr><td class="PType first"><span class="SHKeyword">int</span>&nbsp;</td><td></td><td class="PName last">x,</td></tr><tr><td class="PType first"><span class="SHKeyword">int</span>&nbsp;</td><td></td><td class="PName last">y</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>place layer to new position, relative to upper left corner of display</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">layer<div class="CDLParameterType">SILLYR*</div></td><td class="CDLDefinition"><p>Layer to place</p></td></tr><tr><td class="CDLEntry">x<div class="CDLParameterType"><span class="SHKeyword">int</span></div></td><td class="CDLDefinition"><p>x position, relative to upper left corner of display</p></td></tr><tr><td class="CDLEntry">y<div class="CDLParameterType"><span class="SHKeyword">int</span></div></td><td class="CDLDefinition"><p>y position, relative to upper left corner of display</p></td></tr></table><div class="CHeading">Remarks</div><ul><li><p>Coordinates can be negative, meaning drawn (partly) &quot;off screen&quot;.&nbsp; Same goes for x,y higher then right lower corner.</p></li><li><p>If you want to stop showing layer, it is still faster and easier to use &lt;sil_hide()&gt; and &lt;sil_show()&gt; instead of setting it outside dimensions of display</p></li></ul></div>
</div>

<a name="sil_putPixelLayer"></a><a name="Topic29"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sil_putPixelLayer</div>
 <div id="NDPrototype29" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> sil_putPixelLayer(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">SILLYR&nbsp;</td><td class="PSymbols">*</td><td class="PName last">layer,</td></tr><tr><td class="PType first">UINT&nbsp;</td><td></td><td class="PName last">x,</td></tr><tr><td class="PType first">UINT&nbsp;</td><td></td><td class="PName last">y,</td></tr><tr><td class="PType first">BYTE&nbsp;</td><td></td><td class="PName last">red,</td></tr><tr><td class="PType first">BYTE&nbsp;</td><td></td><td class="PName last">green,</td></tr><tr><td class="PType first">BYTE&nbsp;</td><td></td><td class="PName last">blue,</td></tr><tr><td class="PType first">BYTE&nbsp;</td><td></td><td class="PName last">alpha</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Draw a pixel on given location inside a layer.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">layer<div class="CDLParameterType">SILLYR*</div></td><td class="CDLDefinition"><p>layer to draw on</p></td></tr><tr><td class="CDLEntry">x<div class="CDLParameterType">UINT</div></td><td class="CDLDefinition"><p>x position, relative from upper left corner of layer</p></td></tr><tr><td class="CDLEntry">y<div class="CDLParameterType">UINT</div></td><td class="CDLDefinition"><p>y position, relative from upper left corner of layer</p></td></tr><tr><td class="CDLEntry">red<div class="CDLParameterType">BYTE</div></td><td class="CDLDefinition"><p>amount of red&nbsp; 0..255</p></td></tr><tr><td class="CDLEntry">green<div class="CDLParameterType">BYTE</div></td><td class="CDLDefinition"><p>amount of green 0..255</p></td></tr><tr><td class="CDLEntry">blue<div class="CDLParameterType">BYTE</div></td><td class="CDLDefinition"><p>amount of blue&nbsp; 0..255</p></td></tr><tr><td class="CDLEntry">alpha<div class="CDLParameterType">BYTE</div></td><td class="CDLDefinition"><p>Opacity -&gt; from 0 (not visible) to 255 (no transparancy)</p></td></tr></table><div class="CHeading">Remarks</div><ul><li><p>you can also used predefined SIL <a href="../index.html#File:sil.h:color_codes" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,24);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >color codes</a>, instead of writing ..layer,35,139,34,alpha.. you can use ..layer,SILCOLOR_FOREST_GREEN,alpha....</p></li><li><p>Any pixels that are not within boundaries of layer are not drawn at all</p></li><li><p>If framebuffer type of layer doesn't support alpha value, alpha will be ignored</p></li><li><p>Although it uses 8 bit values for RGB, if framebuffer type of layer uses less bits for each color, they will be adjusted</p></li></ul></div>
</div>

<a name="sil_blendPixelLayer"></a><a name="Topic30"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sil_blendPixelLayer</div>
 <div id="NDPrototype30" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> sil_blendPixelLayer(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">SILLYR&nbsp;</td><td class="PSymbols">*</td><td class="PName last">layer,</td></tr><tr><td class="PType first">UINT&nbsp;</td><td></td><td class="PName last">x,</td></tr><tr><td class="PType first">UINT&nbsp;</td><td></td><td class="PName last">y,</td></tr><tr><td class="PType first">BYTE&nbsp;</td><td></td><td class="PName last">red,</td></tr><tr><td class="PType first">BYTE&nbsp;</td><td></td><td class="PName last">green,</td></tr><tr><td class="PType first">BYTE&nbsp;</td><td></td><td class="PName last">blue,</td></tr><tr><td class="PType first">BYTE&nbsp;</td><td></td><td class="PName last">alpha</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Draw a pixel on given location inside a layer and blend it with existing pixel</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">layer<div class="CDLParameterType">SILLYR*</div></td><td class="CDLDefinition"><p>layer to draw on</p></td></tr><tr><td class="CDLEntry">x<div class="CDLParameterType">UINT</div></td><td class="CDLDefinition"><p>x position, relative from upper left corner of layer</p></td></tr><tr><td class="CDLEntry">y<div class="CDLParameterType">UINT</div></td><td class="CDLDefinition"><p>y position, relative from upper left corner of layer</p></td></tr><tr><td class="CDLEntry">red<div class="CDLParameterType">BYTE</div></td><td class="CDLDefinition"><p>amount of red&nbsp; 0..255</p></td></tr><tr><td class="CDLEntry">green<div class="CDLParameterType">BYTE</div></td><td class="CDLDefinition"><p>amount of green 0..255</p></td></tr><tr><td class="CDLEntry">blue<div class="CDLParameterType">BYTE</div></td><td class="CDLDefinition"><p>amount of blue&nbsp; 0..255</p></td></tr><tr><td class="CDLEntry">alpha<div class="CDLParameterType">BYTE</div></td><td class="CDLDefinition"><p>Opacity -&gt; from 0 (not visible) to 255 (no transparancy)</p></td></tr></table><div class="CHeading">Remarks</div><ul><li><p>you can also used predefined SIL <a href="../index.html#File:sil.h:color_codes" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,24);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >color codes</a>, instead of writing ..layer,35,139,34,alpha.. you can use ..layer,SILCOLOR_FOREST_GREEN,alpha....</p></li><li><p>Any pixels that are not within boundaries of layer are not drawn at all</p></li><li><p>Although it uses 8 bit values for RGB, if framebuffer type of layer uses less bits for each color, they will be adjusted</p></li><li><p>This function is in the rare case you want to overwrite pixels or framebuffer/display type doesn't support alpha blending. But in other cases, if you want to blend images, it is easier -and much faster !- to have each image in a seperate layer and use alpha settings of layers to blend them</p></li></ul></div>
</div>

<a name="sil_getPixelLayer"></a><a name="Topic31"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sil_getPixelLayer</div>
 <div id="NDPrototype31" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> sil_getPixelLayer(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">SILLYR&nbsp;</td><td class="PSymbols">*</td><td class="PName last">layer,</td></tr><tr><td class="PType first">UINT&nbsp;</td><td></td><td class="PName last">x,</td></tr><tr><td class="PType first">UINT&nbsp;</td><td></td><td class="PName last">y,</td></tr><tr><td class="PType first">BYTE&nbsp;</td><td class="PSymbols">*</td><td class="PName last">red,</td></tr><tr><td class="PType first">BYTE&nbsp;</td><td class="PSymbols">*</td><td class="PName last">green,</td></tr><tr><td class="PType first">BYTE&nbsp;</td><td class="PSymbols">*</td><td class="PName last">blue,</td></tr><tr><td class="PType first">BYTE&nbsp;</td><td class="PSymbols">*</td><td class="PName last">alpha</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>get red,green,blue and alpha information for pixel on given location inside a layer.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">layer<div class="CDLParameterType">SILLYR*</div></td><td class="CDLDefinition"><p>layer to draw on</p></td></tr><tr><td class="CDLEntry">x<div class="CDLParameterType">UINT</div></td><td class="CDLDefinition"><p>x position, relative from upper left corner of layer</p></td></tr><tr><td class="CDLEntry">y<div class="CDLParameterType">UINT</div></td><td class="CDLDefinition"><p>y position, relative from upper left corner of layer</p></td></tr><tr><td class="CDLEntry">red<div class="CDLParameterType">BYTE*</div></td><td class="CDLDefinition"><p>return amount of red&nbsp; 0..255</p></td></tr><tr><td class="CDLEntry">green<div class="CDLParameterType">BYTE*</div></td><td class="CDLDefinition"><p>return amount of green 0..255</p></td></tr><tr><td class="CDLEntry">blue<div class="CDLParameterType">BYTE*</div></td><td class="CDLDefinition"><p>return amount of blue&nbsp; 0..255</p></td></tr><tr><td class="CDLEntry">alpha<div class="CDLParameterType">BYTE*</div></td><td class="CDLDefinition"><p>return Opacity -&gt; from 0 (not visible) to 255 (no transparancy)</p></td></tr></table><div class="CHeading">Remarks</div><ul><li><p>you can also used predefined SIL <a href="../index.html#File:sil.h:color_codes" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,24);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >color codes</a>, instead of writing ..layer,35,139,34,alpha.. you can use ..layer,SILCOLOR_FOREST_GREEN,alpha....</p></li><li><p>all RGB codes are returned as bytes. If Framebuffer uses fewer bits, they will be translated to 8 bits.</p></li><li><p>If framebuffer type doesn't support alpha value, 255 will be returned.</p></li><li><p>Any pixels that are not within boundaries of layer will be returning zero for all values</p></li></ul></div>
</div>

<a name="sil_setFlags"></a><a name="Topic27"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sil_setFlags</div>
 <div id="NDPrototype27" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> sil_setFlags(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">SILLYR&nbsp;</td><td class="PSymbols">*</td><td class="PName last">layer,</td></tr><tr><td class="PType first">BYTE&nbsp;</td><td></td><td class="PName last">flags</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>set layer flags</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">layer<div class="CDLParameterType">SILLYR*</div></td><td class="CDLDefinition"><p>layer to set flags of</p></td></tr><tr><td class="CDLEntry">flags<div class="CDLParameterType">BYTE</div></td><td class="CDLDefinition"><p>one or more flags to set, joined by bitwise &quot;or&quot; ('|')</p></td></tr></table><div class="CHeading">Flags</div><table class="CDefinitionList"><tr><td class="CDLEntry">SILFLAG_INVISIBLE</td><td class="CDLDefinition"><p>don't show layer, don't scan for mouse handlers.&nbsp; Setting and resetting is the same as &lt;sil_hide()&gt; and &lt;sil_show()&gt;</p></td></tr><tr><td class="CDLEntry">SILFLAG_NOBLEND</td><td class="CDLDefinition"><p>don't use blend when drawing text</p></td></tr><tr><td class="CDLEntry">SILFLAG_VIEWPOSSTAY</td><td class="CDLDefinition"><p>if view is changed of layer, keep the layer at same position</p></td></tr><tr><td class="CDLEntry">SILFLAG_MOUSESHIELD</td><td class="CDLDefinition"><p>Stop scanning for layers with mouse handlers under this layer</p></td></tr><tr><td class="CDLEntry">SILFLAG_MOUSEALLPIX</td><td class="CDLDefinition"><p>When scanning for valid mouse handlers, all pixels of this layer are eligable , instead of only visible ones</p></td></tr><tr><td class="CDLEntry">SILFLAG_FREEUSER</td><td class="CDLDefinition"><p>Let SIL free up any userdefined memory pointed by layer-&gt;user when layer is destroyed</p></td></tr></table></div>
</div>

<a name="sil_clearFlags"></a><a name="Topic33"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sil_clearFlags</div>
 <div id="NDPrototype33" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> sil_clearFlags(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">SILLYR&nbsp;</td><td class="PSymbols">*</td><td class="PName last">layer,</td></tr><tr><td class="PType first">BYTE&nbsp;</td><td></td><td class="PName last">flags</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>clear one or more flags from layer</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">layer<div class="CDLParameterType">SILLYR*</div></td><td class="CDLDefinition"><p>layer that has the flags</p></td></tr><tr><td class="CDLEntry">flags<div class="CDLParameterType">BYTE</div></td><td class="CDLDefinition"><p>one or more flags to clear, joined by bitwise &quot;or&quot; ('|')</p></td></tr></table><div class="CHeading">Flags</div><table class="CDefinitionList"><tr><td class="CDLEntry">SILFLAG_INVISIBLE</td><td class="CDLDefinition"><p>don't show layer, don't scan for mouse handlers.&nbsp; Setting and resetting is the same as &lt;sil_hide()&gt; and &lt;sil_show()&gt;</p></td></tr><tr><td class="CDLEntry">SILFLAG_NOBLEND</td><td class="CDLDefinition"><p>don't use blend when drawing text</p></td></tr><tr><td class="CDLEntry">SILFLAG_VIEWPOSSTAY</td><td class="CDLDefinition"><p>if view is changed of layer, keep the layer at same position</p></td></tr><tr><td class="CDLEntry">SILFLAG_MOUSESHIELD</td><td class="CDLDefinition"><p>Stop scanning for layers with mouse handlers under this layer</p></td></tr><tr><td class="CDLEntry">SILFLAG_MOUSEALLPIX</td><td class="CDLDefinition"><p>When scanning for valid mouse handlers, all pixels of this layer are eligable , instead of only visible ones</p></td></tr><tr><td class="CDLEntry">SILFLAG_FREEUSER</td><td class="CDLDefinition"><p>Let SIL free up any userdefined memory pointed by layer-&gt;user when layer is destroyed</p></td></tr></table></div>
</div>

<a name="sil_checkFlags"></a><a name="Topic32"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sil_checkFlags</div>
 <div id="NDPrototype32" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">UINT sil_checkFlags(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">SILLYR&nbsp;</td><td class="PSymbols">*</td><td class="PName last">layer,</td></tr><tr><td class="PType first">BYTE&nbsp;</td><td></td><td class="PName last">flags</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>check if one or more flags are set for given layer</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">layer<div class="CDLParameterType">SILLYR*</div></td><td class="CDLDefinition"><p>layer to get flags from</p></td></tr><tr><td class="CDLEntry">flags<div class="CDLParameterType">BYTE</div></td><td class="CDLDefinition"><p>one or more flags to check on, joined by bitwise &quot;or&quot; ('|')</p></td></tr></table><div class="CHeading">Flags</div><table class="CDefinitionList"><tr><td class="CDLEntry">SILFLAG_INVISIBLE</td><td class="CDLDefinition"><p>don't show layer, don't scan for mouse handlers.&nbsp; Setting and resetting is the same as &lt;sil_hide()&gt; and &lt;sil_show()&gt;</p></td></tr><tr><td class="CDLEntry">SILFLAG_NOBLEND</td><td class="CDLDefinition"><p>don't use blend when drawing text</p></td></tr><tr><td class="CDLEntry">SILFLAG_VIEWPOSSTAY</td><td class="CDLDefinition"><p>if view is changed of layer, keep the layer at same position</p></td></tr><tr><td class="CDLEntry">SILFLAG_MOUSESHIELD</td><td class="CDLDefinition"><p>Stop scanning for layers with mouse handlers under this layer</p></td></tr><tr><td class="CDLEntry">SILFLAG_MOUSEALLPIX</td><td class="CDLDefinition"><p>When scanning for valid mouse handlers, all pixels of this layer are eligable , instead of only visible ones</p></td></tr><tr><td class="CDLEntry">SILFLAG_FREEUSER</td><td class="CDLDefinition"><p>Let SIL free up any userdefined memory pointed by layer-&gt;user when layer is destroyed</p></td></tr></table><div class="CHeading">Returns</div><p>zero if not all given flags are set, one if they are</p></div>
</div>

<a name="sil_getBottom"></a><a name="Topic35"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sil_getBottom</div>
 <div id="NDPrototype35" class="NDPrototype"><div class="PSection PPlainSection">SILLYR *sil_getBottom()</div></div>
 <div class="CBody"><p>get layer on the bottom of the stack</p><div class="CHeading">Returns</div><p>Pointer to bottom layer (suprise)</p><div class="CHeading">Remarks</div><p>If you want to iterate to all layers, you can do it the best from bottom till top, by following the layer-&gt;next link</p></div>
</div>

<a name="sil_getTop"></a><a name="Topic36"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sil_getTop</div>
 <div id="NDPrototype36" class="NDPrototype"><div class="PSection PPlainSection">SILLYR *sil_getTop()</div></div>
 <div class="CBody"><p>get the top most layer</p><div class="CHeading">Returns</div><p>Pointer to top layer</p></div>
</div>

<a name="sil_destroyLayer"></a><a name="Topic37"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sil_destroyLayer</div>
 <div id="NDPrototype37" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> sil_destroyLayer(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">SILLYR&nbsp;</td><td class="PSymbols">*</td><td class="PName last">layer</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>remove layer from stack and delete it</p><div class="CHeading">Remarks</div><p>If layer flag <b>SILFLAG_FREEUSER</b> is set and layer-&gt;user is not NULL, it will free any allocated memory pointed by layer-&gt;user.</p></div>
</div>

<a name="sil_setAlphaLayer"></a><a name="Topic38"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sil_setAlphaLayer</div>
 <div id="NDPrototype38" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters"><span class="SHKeyword">void</span> sil_setAlphaLayer(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">SILLYR&nbsp;</td><td class="PSymbols">*</td><td class="PName last">layer,</td></tr><tr><td class="PType first"><span class="SHKeyword">float</span>&nbsp;</td><td></td><td class="PName last">alpha</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>set alpha blending factor for layer</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">layer<div class="CDLParameterType">SILLYR*</div></td><td class="CDLDefinition"><p>layer to set alpha value</p></td></tr><tr><td class="CDLEntry">alpha<div class="CDLParameterType"><span class="SHKeyword">float</span></div></td><td class="CDLDefinition"><p>alpha value 0.0 (transparant) to 1.0 (opaque)</p></td></tr></table><div class="CHeading">Remarks</div><ul><li><p>Be aware: Although alpha values in pixel functions do use range from 0 to 255, this one uses 0 to 1.0 as float</p></li><li><p>Setting this value on non-SDL platforms might slow down update proces because all pixels had to be calculated seperately.</p></li></ul></div>
</div>

<a name="sil_addCopy"></a><a name="Topic21"></a><div class="CTopic TFunction LC">
 <div class="CTitle">sil_addCopy</div>
 <div id="NDPrototype21" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">SILLYR *sil_addCopy(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">SILLYR&nbsp;</td><td class="PSymbols">*</td><td class="PName last">layer,</td></tr><tr><td class="PType first"><span class="SHKeyword">int</span>&nbsp;</td><td></td><td class="PName last">relx,</td></tr><tr><td class="PType first"><span class="SHKeyword">int</span>&nbsp;</td><td></td><td class="PName last">rely</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>creates a new layer, but copies all layer information to new one.The New layer will be placed at given x,y postion</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">layer<div class="CDLParameterType">SILLYR*</div></td><td class="CDLDefinition"><p>pointer to layer to copy</p></td></tr><tr><td class="CDLEntry">relx<div class="CDLParameterType"><span class="SHKeyword">int</span></div></td><td class="CDLDefinition"><p>x position of new layer relative to top left of display</p></td></tr><tr><td class="CDLEntry">rely<div class="CDLParameterType"><span class="SHKeyword">int</span></div></td><td class="CDLDefinition"><p>y position of new layer relative to top left of display</p></td></tr></table><div class="CHeading">Returns</div><p>pointer to newly created layer</p></div>
</div>

<a name="sil_addInstance"></a><a name="Topic16"></a><div class="CTopic TFunction LC last">
 <div class="CTitle">sil_addInstance</div>
 <div id="NDPrototype16" class="NDPrototype WideForm"><div class="PSection PParameterSection CStyle"><table><tr><td class="PBeforeParameters">SILLYR *sil_addInstance(</td><td class="PParametersParentCell"><table class="PParameters"><tr><td class="PType first">SILLYR&nbsp;</td><td class="PSymbols">*</td><td class="PName last">layer,</td></tr><tr><td class="PType first"><span class="SHKeyword">int</span>&nbsp;</td><td></td><td class="PName last">relx,</td></tr><tr><td class="PType first"><span class="SHKeyword">int</span>&nbsp;</td><td></td><td class="PName last">rely</td></tr></table></td><td class="PAfterParameters">)</td></tr></table></div></div>
 <div class="CBody"><p>Create an extra instance of given layer. New layer will share the same framebuffer as the original, so all drawings and filters on it will be the same as the original, however, the new layer can have different position, view, visability or handlers.</p><p>Use this to save memory when using the same image over and over again, like &quot;tiling&quot; a background.</p><div class="CHeading">Parameters</div><table class="CDefinitionList"><tr><td class="CDLEntry">layer<div class="CDLParameterType">SILLYR*</div></td><td class="CDLDefinition"><p>pointer to layer to instanciate from</p></td></tr><tr><td class="CDLEntry">relx<div class="CDLParameterType"><span class="SHKeyword">int</span></div></td><td class="CDLDefinition"><p>x position of new layer relative to top left of display</p></td></tr><tr><td class="CDLEntry">rely<div class="CDLParameterType"><span class="SHKeyword">int</span></div></td><td class="CDLDefinition"><p>y position of new layer relative to top left of display</p></td></tr></table><div class="CHeading">Returns</div><p>pointer to newly created layer</p><div class="CHeading">Remarks</div><p>The only advantage of this function is that it will save memory. However, if you use SDL, every layer -including instanciated ones- will end up having a seperate texture to be send to GPU, therefore, it isn't recommended to use this function for SDL environments.&nbsp; If you just want a copy of an existing layer, use <a href="../index.html#File:layer.c:sil_addCopy" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,21);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >sil_addCopy()</a> instead</p></div>
</div>

</body></html>